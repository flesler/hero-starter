const a=["North","South","East","West"],b="Stay",c="HealthWell",d="DiamondMine",e="Impassable",f="Unoccupied",g="Hero",h="_",i=100,j=20,k=30,l=20,m=30;let n,o,p,q;function r(a){return Array.prototype.concat.apply([],a)}function s(a){switch(typeof a){case"object":return b=>b===a;case"string":return b=>b.type===a;case"function":return a;}}function t(a,b){return b=s(b),a.reduce((a,c)=>a+(b(c)||0),0)}function u(a,b){return b=s(b),t(a,a=>b(a)?1:0)}function v(a){return a.sort(()=>Math.random()-.5)}function w(a,c=p){return a===c?{direction:b,distance:0}:o.findNearestObjectDirectionAndDistance(n.board,c,s(a))}function z(a,b=p){const c=w(a,b);return c?c.distance:1/0}function x(b){return v(a).map(a=>o.getTileNearby(n.board,b.y,b.x,a)).filter(a=>!!a)}function y(a,b=p){return u(x(b),a)}function A(a,b=p){return 0<y(a,b)}function B(a=p){return A(c,a)}function C(a,b){return a.walkable&&a.nextToHero&&A(b,a)}function D(a=p){return 1<y(K,a)}function E(a=p){const b="number"==typeof a?a:a.health;return Math.ceil(b/k)}function F(a){for(const b of x(a))b.type===f&&(b.type=h)}function G(){return q.filter(a=>a.type===h)}function H(){q.filter(K).forEach(F);const a=w(c),b=w(a=>a.nextToHero&&a.type===f);G().forEach(F);const d=w(c),e=w(a=>a.nextToHero&&a.type===f);for(const a of G())a.type===h&&(a.type=f);return d||a||e||b||w(c)}function I(a){return a.type===d&&(!a.owner||a.owner.enemy)}function J(){return 1===n.healthWells.length}function K(a){return a.enemy}function L(){q=r(n.board.tiles);for(const a of q)a.x=a.distanceFromLeft,a.y=a.distanceFromTop,a.name===n.activeHero.name&&(n.activeHero=a,p=a);for(const a of q){const{x:b,y:c,type:d}=a;a.pos=`(${b}, ${c})`,a.soul=/Fainted/.test(a.subType),a.distanceToHero=z(a),a.nextToHero=1===a.distanceToHero,a.walkable=d===f||a===p||!!a.dead,d===g&&(a.damaged=i-a.health,a.ally=a!==p&&a.team===p.team,a.enemy=a.team!==p.team),delete a.direction}}const M=[a=>a.enemy&&a.nextToHero&&a.health<=k&&a.health>j,a=>a.enemy&&a.nextToHero&&a.health<=k,a=>C(a,a=>a.enemy&&a.health<=j),a=>D()&&C(a,c),a=>a.type===c&&a.nextToHero&&p.damaged>=m,()=>D()&&H(),a=>a.enemy&&a.nextToHero&&(!B(a)||B())&&z(c)-1>=p.health/j,a=>a.enemy&&a.nextToHero&&(!B(a)||B())&&E()>=E(a),a=>a.enemy&&a.nextToHero&&p.damaged&&H(),a=>J()&&p.damaged&&C(a,c),a=>J()&&a.ally&&a.nextToHero&&!!a.damaged,()=>J()&&(p.damaged||!B())&&H(),a=>!D(a)&&C(a,b=>b.enemy&&(!B(b)||B(a))&&E()>E(b.health-j)),()=>p.health>l&&(!B()||!p.damaged)&&z(K)===1/0&&w(I),()=>.6>=p.health/i&&H(),a=>a.nextToHero&&I(a)&&B(),a=>a.ally&&a.nextToHero&&!!a.damaged,a=>a.enemy&&!B(a)&&E()>E(a.health-j)&&2!==a.distanceToHero,a=>a.enemy&&!B(a)&&E(p.health-j)>=E(a),a=>C(a,a=>a.enemy&&A(a=>a.ally,a)),()=>p.damaged>l&&H(),()=>p.damaged&&w(c),a=>a.soul&&a.nextToHero];module.exports=(a,c)=>{n=a,o=c,L(),p.plan=null;const d=[];for(const b of q){if(b===p||b.type===e||b.distanceToHero===1/0)continue;const a=b.distanceToHero;d[a]?d[a].push(b):d[a]=[b]}for(const b of d)if(b)for(const a of M)for(const c of b){let b=a(c);if(b){if(p.plan=a,!0===b&&(b=c),b&&b.type){if(b.direction||(b=w(b)),!b)continue;p.destination=b}if(b&&b.direction&&(b=b.direction),"string"==typeof b)return b;if(!a.length)break}}return b};